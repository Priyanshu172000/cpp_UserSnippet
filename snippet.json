{
	// Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
	// description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
	// same ids are connected.
	// Example:
	"CPP": {
		"prefix": "cpp_bp",
		"body": [
			"/*",
			"Author: Priyanshu",
			"Created@: $CURRENT_DATE-$CURRENT_MONTH-$CURRENT_YEAR   $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND",
			"*/",
			" ",
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"#define int long long",
			"signed main()",
			"{",
			"    ios::sync_with_stdio(0);",
			"    cin.tie(0);",
			"    for (int tt = (cin >> tt, tt); tt--;)",
			"    {",
			"        $1",
			"    }",
			"    return 0;",
			"}"
		],
		"description": "Log output to console"
	},
	"PBDS": {
		"prefix": "pbds",
		"body": [
			"#include <ext/pb_ds/assoc_container.hpp>",
			"#include <ext/pb_ds/tree_policy.hpp>",
			"using namespace __gnu_pbds;",
			"typedef tree<long long, null_type, less_equal<long long>, rb_tree_tag, tree_order_statistics_node_update> ordered_set;"
		],
		"description": "Log output to console"
	},
	"Binpow": {
		"prefix": "powmodm",
		"body": [
			"int modPow(int a, int b, int m)",
			"{",
			"int res = 1;",
			"    while (b > 0)",
			"    {",
			"        if (b % 2 == 1)",
			"            res = (res * a) % m;",
			"        a = (a * a) % m;",
			"        b /= 2;",
			"    }",
			"    return res;",
			"}",
			"int modInverse(int a, int m)",
			"{",
			"    return modPow(a, m - 2, m);",
			"}",
			"vector<int> NCRModM(int n, int m)",
			"{",
			"    vector<int> fact(n + 1, 1);",
			"    vector<int> invFact(n + 1, 1);",
			"    for (int i = 2; i <= n; ++i)",
			"        fact[i] = (fact[i - 1] * i) % m;",
			"    invFact[n] = modInverse(fact[n], m);",
			"    for (int i = n - 1; i >= 1; --i)",
			"        invFact[i] = (invFact[i + 1] * (i + 1)) % m;",
			"    vector<int> ncr(n + 1, 1);",
			"    for (int r = 1; r <= n; ++r)",
			"        ncr[r] = (fact[n] * invFact[r] % m * invFact[n - r] % m) % m;",
			"    return ncr;",
			"}"
		],
		"description": "Log output to console"
	},
	"SEG": {
		"prefix": "segtree",
		"body": [
			"void build(int a[], int seg[], int i, int lo, int hi)",
			"{",
			"    if (lo == hi)",
			"    {",
			"        seg[i] = a[lo];",
			"        return;",
			"    }",
			"    int mid = (lo + hi) / 2;",
			"    build(a, seg, 2 * i + 1, lo, mid);",
			"    build(a, seg, 2 * i + 2, mid + 1, hi);",
			"    seg[i] = min(seg[2 * i + 1], seg[2 * i + 2]);",
			"}",
			"void update(int seg[], int i, int lo, int hi, int k, int v)",
			"{",
			"    if (lo == hi && lo == k)",
			"    {",
			"        seg[i] = v;",
			"        return;",
			"    }",
			"    if (k < lo || k > hi)",
			"        return;",
			"    int mid = (lo + hi) / 2;",
			"    update(seg, 2 * i + 1, lo, mid, k, v);",
			"    update(seg, 2 * i + 2, mid + 1, hi, k, v);",
			"    seg[i] = min(seg[2 * i + 1], seg[2 * i + 2]);",
			"}",
			"int query(int seg[], int i, int lo, int hi, int l, int r)",
			"{",
			"    if (l <= lo && r >= hi)",
			"        return seg[i];",
			"    if (r < lo || l > hi)",
			"        return INT_MAX;",
			"    int mid = (lo + hi) / 2;",
			"    int left = query(seg, 2 * i + 1, lo, mid, l, r);",
			"    int right = query(seg, 2 * i + 2, mid + 1, hi, l, r);",
			"    return min(left, right);",
			"}"
		],
		"description": "Log output to console"
	},
	"lazyseg": {
		"prefix": "lazysegtree",
		"body": [
			"void build(int a[], int seg[], int i, int lo, int hi)",
			"{",
			"    if (lo == hi)",
			"    {",
			"        seg[i] = a[lo];",
			"        return;",
			"    }",
			"    int mid = (lo + hi) / 2;",
			"    build(a, seg, 2 * i + 1, lo, mid);",
			"    build(a, seg, 2 * i + 2, mid + 1, hi);",
			"    seg[i] = seg[2 * i + 1] + seg[2 * i + 2];",
			"}",
			"void update(int seg[], int lazy[], int i, int lo, int hi, int l, int r, int v)",
			"{",
			"    if (lazy[i])",
			"    {",
			"        seg[i] += (hi - lo + 1) * lazy[i];",
			"        if (lo != hi)",
			"        {",
			"            lazy[2 * i + 1] += lazy[i];",
			"            lazy[2 * i + 2] += lazy[i];",
			"        }",
			"        lazy[i] = 0;",
			"    }",
			"    if (hi < l || lo > r || lo > hi)",
			"        return;",
			"    if (lo >= l && hi <= r)",
			"    {",
			"        seg[i] += (hi - lo + 1) * v;",
			"        if (lo != hi)",
			"        {",
			"            lazy[2 * i + 1] += v;",
			"            lazy[2 * i + 2] += v;",
			"        }",
			"        return;",
			"    }",
			"    int mid = (lo + hi) / 2;",
			"    update(seg, lazy, 2 * i + 1, lo, mid, l, r, v);",
			"    update(seg, lazy, 2 * i + 2, mid + 1, hi, l, r, v);",
			"    seg[i] = seg[2 * i + 1] + seg[2 * i + 2];",
			"}",
			"int query(int seg[], int lazy[], int i, int lo, int hi, int l)",
			"{",
			"    if (lazy[i])",
			"    {",
			"        seg[i] += (hi - lo + 1) * lazy[i];",
			"        if (lo != hi)",
			"        {",
			"            lazy[2 * i + 1] += lazy[i];",
			"            lazy[2 * i + 2] += lazy[i];",
			"        }",
			"        lazy[i] = 0;",
			"    }",
			"    if (hi < l || lo > l)",
			"        return 0;",
			"    if (lo == hi && lo == l)",
			"    {",
			"        return seg[i];",
			"    }",
			"    int mid = (lo + hi) / 2;",
			"    int left = query(seg, lazy, 2 * i + 1, lo, mid, l);",
			"    int right = query(seg, lazy, 2 * i + 2, mid + 1, hi, l);",
			"    return left + right;",
			"}"
		],
		"description": "lazyseg"
	}
}
